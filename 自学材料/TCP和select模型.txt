HTTP 1.0短连接
HTTP 1.1长连接
HTTP 2.0

TCP 三次握手，四次挥手
客户端A，服务端B

四次挥手：客户端向服务器说要关闭发送
	 服务器向客户端回一个请求：收到
	 服务器向客户端发送：关闭收
	 客户端向服务器发送：收到
为什么是四次挥手：
	服务器可能还在处理数据，所以第二步和第三步不能合并

	第三步已发送，第四步发出时，如果B一直没收到，则会向A再发送请求。	
	避免新旧挥手的连接时间长，大概是2分钟。超过2分钟，就不会再发送
	
四次挥手会导致什么问题：
	read()方法会解开阻塞，服务端的tomcat即使断开，服务端还可以继续做自己的事情

socket是ip+端口的文件（linux角度）

nio底层是根据操作系统而定，如果是windows，使用windows的select
			如果是linux，如果系统是SunOS，DevPollSelector
				     如果是linux，使用EPollSelector

select模型的缺点：只能监听1024个，并且会造成不必要的循环